import { NextRequest, NextResponse } from 'next/server';
import { generateChristmasPrompt } from '@/app/lib/prompt-generator';
import { uploadToBlob } from '@/app/lib/blob';
import { randomBytes } from 'crypto';
import Replicate from 'replicate';
import { videoStore, getCurrentVideoId, setCurrentVideoId } from '@/app/lib/video-store';

export async function POST(request: NextRequest) {
  try {
    // Check if a video already exists
    if (getCurrentVideoId()) {
      return NextResponse.json({ error: 'A video has already been created. Please reset first.' }, { status: 400 });
    }

    const formData = await request.formData();
    const file = formData.get('selfie') as File;

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    // Validate file type
    if (!file.type.startsWith('image/')) {
      return NextResponse.json({ error: 'File must be an image' }, { status: 400 });
    }

    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      return NextResponse.json({ error: 'File size must be less than 10MB' }, { status: 400 });
    }

    // Convert file to base64 for GPT-4 Vision
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const base64Image = buffer.toString('base64');

    // Step 1: Use OpenAI GPT-4 Vision to generate hilarious Christmas prompt from selfie
    console.log('Step 1: Using OpenAI GPT-4 Vision to generate prompt from selfie...');
    const prompt = await generateChristmasPrompt(base64Image);
    console.log('✅ OpenAI generated prompt:', prompt);
    console.log('Prompt length:', prompt.length, 'characters');

    // Step 2: Upload selfie to blob for reference (for storage/backup)
    const selfieBlobUrl = await uploadToBlob(
      `selfies/${Date.now()}-${file.name}`,
      buffer,
      file.type
    );
    console.log('Selfie uploaded to:', selfieBlobUrl);

    // Step 3: Use Replicate to generate video using the OpenAI-generated prompt
    console.log('Step 2: Using Replicate to generate video with OpenAI prompt...');
    console.log('Replicate will use this OpenAI-generated prompt:', prompt);
    
    if (!process.env.REPLICATE_API_TOKEN) {
      throw new Error('REPLICATE_API_TOKEN is not set. Please add it to your .env.local file.');
    }
    
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_TOKEN,
    });
    
    // Use the blob URL for the image input
    const imageInput = selfieBlobUrl;
    
    // Generate video with Replicate using OpenAI-generated prompt
    // Using Google Veo 3 - supports image and prompt input
    console.log('Calling Replicate API with OpenAI prompt and selfie using Google Veo 3...');
    const output = await replicate.run(
      "google/veo-3" as `${string}/${string}`,
      {
        input: {
          prompt: prompt, // OpenAI GPT-4 Vision generated this prompt
          image: imageInput, // Selfie image
          duration: 8, // Must be 4, 6, or 8 seconds
        }
      }
    );
    
    console.log('✅ Replicate generated video successfully!');
    console.log('Replicate output:', output);
    
    // Replicate may return a URL, ReadableStream, or array
    let videoBuffer: Buffer;
    
    if (output instanceof ReadableStream) {
      // Convert ReadableStream to Buffer
      const chunks: Uint8Array[] = [];
      const reader = output.getReader();
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (value) chunks.push(value);
      }
      
      // Combine all chunks into a single buffer
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const combined = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        combined.set(chunk, offset);
        offset += chunk.length;
      }
      videoBuffer = Buffer.from(combined);
    } else {
      // It's a URL string or array of URLs
      const videoUrl = Array.isArray(output) ? output[0] : output;
      
      if (!videoUrl || typeof videoUrl !== 'string') {
        throw new Error('No video URL returned from Replicate');
      }
      
      console.log('Video generated by Replicate:', videoUrl);
      
      // Download video from Replicate
      const videoResponse_fetch = await fetch(videoUrl);
      if (!videoResponse_fetch.ok) {
        throw new Error('Failed to download video from Replicate');
      }
      
      videoBuffer = Buffer.from(await videoResponse_fetch.arrayBuffer());
    }
    const videoId = randomBytes(16).toString('hex');
    const videoBlobUrl = await uploadToBlob(
      `videos/${videoId}.mp4`,
      videoBuffer,
      'video/mp4'
    );
    
    console.log('Video uploaded to blob:', videoBlobUrl);
    
    videoStore.set(videoId, {
      url: videoBlobUrl,
      prompt: prompt,
      createdAt: new Date(),
    });
    
    // Set this as the current video (only one allowed)
    setCurrentVideoId(videoId);
    
    return NextResponse.json({
      videoId,
      videoUrl: videoBlobUrl,
      prompt,
    });

  } catch (error) {
    console.error('Error generating video:', error);
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : 'Failed to generate video',
      },
      { status: 500 }
    );
  }
}

// API endpoint to get current video - checks blob storage for latest video
export async function GET() {
  try {
    const { listVideosFromBlob } = await import('@/app/lib/blob');
    const videos = await listVideosFromBlob();
    
    if (videos.length === 0) {
      return NextResponse.json({ videoId: null });
    }
    
    // Get the latest video (already sorted by newest first)
    const latestVideo = videos[0];
    
    // Extract video ID from pathname (e.g., "videos/abc123.mp4" -> "abc123")
    const videoId = latestVideo.pathname.replace('videos/', '').replace('.mp4', '');
    
    // Try to get prompt from in-memory store, or use a default
    const videoData = videoStore.get(videoId);
    const prompt = videoData?.prompt || 'A Christmas video created with Justin\'s AI magic!';
    
    return NextResponse.json({
      videoId,
      videoUrl: latestVideo.url,
      prompt,
      createdAt: latestVideo.uploadedAt.toISOString(),
    });
  } catch (error) {
    console.error('Error getting latest video:', error);
    return NextResponse.json({ videoId: null });
  }
}

